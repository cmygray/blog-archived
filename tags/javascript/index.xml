<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on cmygray</title>
    <link>http://cmygray.github.io/tags/javascript/</link>
    <description>Recent content in Javascript on cmygray</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 10 Jan 2018 22:32:56 +0900</lastBuildDate>
    
	<atom:link href="http://cmygray.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>You Don&#39;t Know JS: 프로토타입</title>
      <link>http://cmygray.github.io/post/til-2018/0110/</link>
      <pubDate>Wed, 10 Jan 2018 22:32:56 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/til-2018/0110/</guid>
      <description>자바스크립트의 중요한 동작원리인 [[Prototype]] 체인과 기존 프로그래밍 언어의 클래스, 객체 지향 패턴을 구분함으로써 오해를 바로잡아주는 한편 어째서 (숱한 개발자들이) 클래스를 통한 객체지향 프로그래밍을 구현하려고 애써왔는지(본문에서는 무려 어거지라고 표현한다!) 궁금하게 만드는 장. 급격하게 팽창한 웹에서 필수적 역할을 했던 자바스크립트에 대해서 &amp;ldquo;가장 오해받는 언어&amp;rdquo;라는 주장을 자주 볼 수 있는데, 이것이 사실인지 항변인지 현재의 나로서는 알 수가 없다. 그 떄문에 객체지향과 클래스를 좀 더 명확하게 알아야 할 필요를 느낀다. 그 수준에 이르면 성능이나 속도, 업계의 수요같은 얕은 요소를 넘어서 더 넓은 시야로 프론트엔드 프레임워크(라이브러리)를 바라볼 수 있을 것 같기 때문이다.</description>
    </item>
    
    <item>
      <title>You Don&#39;t Know JS: 클래스와 객체의 혼합</title>
      <link>http://cmygray.github.io/post/til-2018/0109/</link>
      <pubDate>Tue, 09 Jan 2018 16:17:08 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/til-2018/0109/</guid>
      <description>앞 장에서 다룬 객체와 이번 장의 내용을 통해 자바스크립트 데이터로써 객체(Object type) 개념보다 확장된, 개발 패턴으로서의 객체 개념을 조금이나마 이해할 수 있었다.
클래스와 객체의 혼합  클래스와 상속은 (&amp;hellip;) 실생활 영역의 문제를 소프트웨어로 모델링 하기 위한 방법이다. (&amp;hellip;) 객체 지향 또는 클래스 지향 프로그래밍에서 (&amp;hellip;) 데이터와 작동을 함께 잘 감싸는 것이 올바른 설계라고 강조한다; Capsulation.
 본문에선 내장 객체 String을 예로 든다. 즉 데이터(문자열 타입)와 관련 동작(문자열 타입 데이터에 필요한 메소드)을 캡슐화한 결과가 바로 자바스크립트의 Native Object, String이다.</description>
    </item>
    
    <item>
      <title>You Don&#39;t Know JS: 객체(마무리)</title>
      <link>http://cmygray.github.io/post/til-2018/0107/</link>
      <pubDate>Sun, 07 Jan 2018 14:53:27 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/til-2018/0107/</guid>
      <description>객체 객체는 0개 이상의 프로퍼티로 구성되며, 프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 나뉜다. 또 ES5부터 모든 프로퍼티는 서술자; Property Descriptor에 의해 표기되며 프로퍼티의 종류에 따라 서술자의 어트리뷰트가 달라진다. 프로퍼티 서술자의 어트리뷰트로는, [[Value]], [[Writable]], [[Configurable]], [[Enumerable]], [[Get]], [[Set]] 등이 있다. 까지가 앞서 살펴본 내용이었다.
 기본적으로 [[Get]] 연산은 주어진 이름의 프로퍼티를 찾아보고 있으면 그 값을 반환한다. 프로퍼티를 찾아보고 없으면 (&amp;hellip;) 다른 중요한 작업을 하도록 정의되어 있는데(&amp;hellip;)
 일반적으로 프로퍼티 접근자를 사용했을 때의 동작을 설명하고 있다.</description>
    </item>
    
    <item>
      <title>You Don&#39;t Know JS: 객체</title>
      <link>http://cmygray.github.io/post/til-2018/0106/</link>
      <pubDate>Sat, 06 Jan 2018 21:40:27 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/til-2018/0106/</guid>
      <description>객체; Object  In ECMAScript, an object is a collection of zero or more properties each with attributes that determine how each property can be used (&amp;hellip;) Properties are containers that hold other objects, primitive values, or functions.
 {}도 객체요, { msg: &#39;hello world&#39; } 또한 객체다. 객체를 구성하는 프로퍼티는 키와 값으로 구분되며, 객체, 원시값, 함수를 값으로 취한다.
프로퍼티 값의 타입이 함수일 때, 흔히 메소드라고 부른다. 하지만 이런 견해도 있다.</description>
    </item>
    
    <item>
      <title>Cracking the Coding Interview (Easy)</title>
      <link>http://cmygray.github.io/post/algorithm/cracking-the-coding-interview-easy/</link>
      <pubDate>Wed, 08 Nov 2017 21:44:23 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/cracking-the-coding-interview-easy/</guid>
      <description>____hackerrank.com에서 제공하는 Cracking the Coding Interview Challenges 알고리즘 퀴즈를 풀어보자. 자료구조, 알고리즘, 테크닉 세 개의 카테고리가 있으며 총 20문제가 있다. 오늘은 Easy 난이도만 풀어보고 나머지 문제는 차차 풀어볼 생각. *Javascript를 사용한다.
문제 설명(공통)
____각 문제에는 Max Score가 정해져 있어 제출 코드의 퀄리티에 따라 다른 점수가 부여된다. 아마도 코드에 복잡도에 따라 점수가 달라지는 것 같다.
____해커랭크 에디터는 Node.js 환경을 제공한다. 인풋을 main함수로 전달해주는 코드가 미리 작성되어 있으므로, 해당 함수 내부에 코드를 작성하면 된다.</description>
    </item>
    
    <item>
      <title>Angular summary!!!</title>
      <link>http://cmygray.github.io/post/angular/angular2_brief_summary/</link>
      <pubDate>Sat, 04 Nov 2017 23:47:30 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/angular/angular2_brief_summary/</guid>
      <description>Angular summary 참고자료
 poiemaweb tutorials  TODO: 질문
sourcemap 파일과 디버깅의 관계 spec.ts를 생성하지 않는 이유  Common AngularJS =&amp;gt; Angular
 Digest Loop 문제 해결
____Two-way binding;양방향 바인딩 데이터의 change detection;변화감지 개선. AoT Compile, Lazy loading 제공
____성능 개선을 위한 추가 기능을 제공한다는 것은.. 쓰지 않으면 그전과 다를 바 없다는 얘기다.  CLI 개발환경으로서 제공하는 기능
 build Unit test, End to end test env support add/rm element Live reload internal server  $ ng new &amp;lt;project-name&amp;gt; [,--skip-install]: create new project [skip package install]</description>
    </item>
    
    <item>
      <title>TypeScript Basics</title>
      <link>http://cmygray.github.io/post/javascript/typescript_basics/</link>
      <pubDate>Sat, 04 Nov 2017 22:56:48 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/javascript/typescript_basics/</guid>
      <description>TypeScript basic syntax and features Class, Interface, Generic
Class 타입스크립트의 클래스는 ES6 클래스와 전반적으로 비슷하지만, 몇가지 고유 기능이 존재한다.
 member var declaration access modifier(public, protected, private default=public) static member var abstract class  Definition ES6
class Person { constructor(name) { this.name = name; // public  } walk() { console.log(`${this.name}walk`); } }  TS
class Person { name: string; // public  constructor(name: string) { this.name = name; } walk() { console.</description>
    </item>
    
    <item>
      <title>ES5, ES6 Class 비교</title>
      <link>http://cmygray.github.io/post/javascript/class/</link>
      <pubDate>Thu, 02 Nov 2017 23:41:50 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/javascript/class/</guid>
      <description>Javascript Class  Definition  ES5 ES6  Inheritance  ES6   Javascrit 튜토리얼 Poiemaweb의 ES6-class컨텐츠를 학습하며 정리한 글입니다.
Definition 자바스크립트는 프로토타입 기반 멀티 패러다임 랭귀지이다. ES5에서는 생성자 함수와 프로토타입을 사용하여 객체 지향 프로그래밍을 구현했다. ES6에서는 Class 키워드를 도입하여 객체 지향 프로그래밍을 지원하지만, 생성자 함수와 프로토타입을 이용한 내부 동작 원리는 같다.
ES5 ES5 클래스 구현 코드 예제
// ES5 var Person = (function () { // 1. 변수 Person에 함수의 반환값을 할당하였다.</description>
    </item>
    
    <item>
      <title>1029_2*n 타일링</title>
      <link>http://cmygray.github.io/post/algorithm/171029_tiling/</link>
      <pubDate>Sun, 29 Oct 2017 20:01:31 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/171029_tiling/</guid>
      <description>문제 2 X n 타일링하기
세로타일 한개를 0 가로타일 두개를 1로 할 때, 경우의 수를 일부만 써보면 아래와 같다. (여기서 뭔가 눈치를 챘어야 하는건데&amp;hellip;.)

n=1|1 |0
n=2|2 |00, 1 (k = 1)
n=3|3 |000, 01 (k = 1)
n=4|5 |0000, 001, 11 (k = 1, 2)
n=5|8 |00000, 0001, 011 (k = 1, 2)
n=6|13|000000, 00001, 0011, 111 (k = 1, 2, 3)
&amp;hellip;

 0만 배열하는 경우는 1가지이므로 계산하지 않는다.</description>
    </item>
    
    <item>
      <title>1024_숫자의 표현</title>
      <link>http://cmygray.github.io/post/algorithm/171024_serialnumbers/</link>
      <pubDate>Sun, 29 Oct 2017 20:00:22 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/171024_serialnumbers/</guid>
      <description>문제 숫자의 표현
함수 expressions는 자연수를 입력받아 해당 숫자를 연속된 자연수의 합으로 표현할 수 있는 방법의 수를 반환한다. 예를 들어 15를 연속된 자연수의 합으로 표현하는 방법은 아래 4가지가 있다.
(1+2+3+4+5)
(4+5+6)
(7+8)
(15)
즉 expressions(15) 의 결과는 4이다.
풀이 임의의 자연수 N을 연속된 n개의 수열의 합으로 표현할 때,
 길이가 같은 수열은 두개 이상 존재할 수 없다 수열의 평균 m = N / n 연속된 수열의 평균은 가운데 수 혹은 가운데 두 수의 중간값이다 즉 (N % n = 0, n은 홀수) 또는 (N % n = 0.</description>
    </item>
    
    <item>
      <title>Ajax</title>
      <link>http://cmygray.github.io/post/javascript/ajax/</link>
      <pubDate>Wed, 18 Oct 2017 23:54:05 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/javascript/ajax/</guid>
      <description>Ajax Asyncronous Javascript and XML
비동기 통신을 이용한 웹 개발 기법

목적
 네트워크 블로킹 상태 억제. 사용성 증대, 패킷 절약.  효용
 페이지의 일부만 갱신 가능. 서버와 통신중에도 방해받지 않음.  방법
 서버와의 통신경과와 전송 데이터와 관련된 동작 스크립트의 실행컨텍스트를 이벤트 루프가 컨트롤하도록 한다. (DOM 객체 수정 스크립트의 실행컨텍스트를 사용자와 페이지 간 인터렉션에 의해 이벤트 루프가 컨트롤 하듯.) XMLHttpRequest 객체와 메소드가 이를 지원한다. 요청을 위해서는 먼저 request 객체를 생성, 요청에 관한 정보를 담아 완성 후 전송한다.</description>
    </item>
    
    <item>
      <title>javascript deep-dive summary</title>
      <link>http://cmygray.github.io/post/javascript/deep-dive/</link>
      <pubDate>Mon, 16 Oct 2017 01:38:59 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/javascript/deep-dive/</guid>
      <description>10월 10일 - 12일 간 배운 자바스크립트 deep-dive에 대한 정리 웹 프로그래밍 튜토리얼과 MDN 자바스크립트 문서를 참고. ES5를 기준으로 하며, ES6에 해당하는 내용은 상단에 @ES6 표시.  
1. Built in Object  오브젝트의 구조
 Host obj(user-made) Built in obj  Standard(global objects of window;global object) Native  BOM DOM    구성 순서: Standards -&amp;gt; Native
  2. Standard built-in Object  구조  Global Object(window;js | global;node)  Global Objects: Object, Function, Boolean, Number, String &amp;hellip;    표준 빌트인 객체에는 글로벌 오브젝트인 윈도우와, 윈도우에 속하는 나머지 글로벌 오브젝트&amp;rsquo;들&amp;rsquo;이 있다.</description>
    </item>
    
    <item>
      <title>다트 게임(카카오 코딩테스트)</title>
      <link>http://cmygray.github.io/post/algorithm/171012_dart_game/</link>
      <pubDate>Thu, 12 Oct 2017 22:31:49 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/171012_dart_game/</guid>
      <description>문제 카카오톡 신입 공채 1차 코딩테스트 2번 문제입니다.
 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수^1 , 점수^2 , 점수^3 )으로 계산된다. 옵션으로 스타상(*) , 아차상(#)이 존재하며 스타상(*) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다. 스타상(*)은 첫 번째 기회에서도 나올 수 있다.</description>
    </item>
    
    <item>
      <title>다음 큰 수 찾기</title>
      <link>http://cmygray.github.io/post/algorithm/171008_next_big_number/</link>
      <pubDate>Sun, 08 Oct 2017 19:21:15 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/171008_next_big_number/</guid>
      <description>문제 어떤 수 N(1≤N≤1,000,000) 이 주어졌을 때, N의 다음 큰 숫자는 다음과 같습니다.
 N의 다음 큰 숫자는 N을 2진수로 바꾸었을 때의 1의 개수와 같은 개수로 이루어진 수입니다. 1번째 조건을 만족하는 숫자들 중 N보다 큰 수 중에서 가장 작은 숫자를 찾아야 합니다.  예를 들어, 78을 2진수로 바꾸면 1001110 이며, 78의 다음 큰 숫자는 83으로 2진수는 1010011 입니다. N이 주어질 때, N의 다음 큰 숫자를 찾는 nextBigNumber 함수를 완성하세요.</description>
    </item>
    
    <item>
      <title>javascript fundamentals summary</title>
      <link>http://cmygray.github.io/post/javascript/fundamentals/</link>
      <pubDate>Sat, 07 Oct 2017 01:15:36 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/javascript/fundamentals/</guid>
      <description>수정내역
10.07. scope, this 내용 보충
 지금(작성일 기준)까지 배운 자바스크립트의 기본 내용을 정리. 웹 프로그래밍 튜토리얼과 MDN 자바스크립트 문서를 참고하여 보완. 추가된 항목은 볼드표시해서 구분. ES5를 기준으로 하며, ES6에 해당하는 내용은 상단에 @ES6 표시.  programming 문제 인식 - 작은 문제로 쪼개기 - 쪼개진 문제를 해결 - 해결의 종합 - 문제 해결
Computational thinking을 토대로 위의 절차를 진행하는 것
basic syntax  sentence;구문
구문이란 자바스크립트 내의 모든 명령이다. 명령은 세미콜론(;)으로 분리된다.</description>
    </item>
    
    <item>
      <title>N개의 최소공배수</title>
      <link>http://cmygray.github.io/post/algorithm/171005_nlcm/</link>
      <pubDate>Thu, 05 Oct 2017 15:05:30 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/171005_nlcm/</guid>
      <description>문제 두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. nlcm 함수를 통해 n개의 숫자가 입력되었을 때, 최소공배수를 반환해 주세요. 예를들어 [2,6,8,14] 가 입력된다면 168을 반환해 주면 됩니다.
풀이  가장 큰 수에 1,2,3&amp;hellip;배 한 값에 대해 다른 수의 나머지 체크 &amp;gt; 연산시간 초과로 실패</description>
    </item>
    
    <item>
      <title>콜라츠 추측</title>
      <link>http://cmygray.github.io/post/algorithm/171004_collatz/</link>
      <pubDate>Wed, 04 Oct 2017 14:30:45 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/171004_collatz/</guid>
      <description>문제: 콜라츠 추측 1937년 Collatz란 사람에 의해 제기된 이 추측은, 입력된 수가 짝수라면 2로 나누고, 홀수라면 3을 곱하고 1을 더한 다음, 결과로 나온 수에 같은 작업을 1이 될 때까지 반복할 경우 모든 수가 1이 된다는 추측입니다. 예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. collatz 함수를 만들어 입력된 수가 몇 번 만에 1이 되는지 반환해 주세요. 단, 500번을 반복해도 1이 되지 않는다면 –1을 반환해 주세요.</description>
    </item>
    
    <item>
      <title>최소값 만들기</title>
      <link>http://cmygray.github.io/post/algorithm/171003_getminsum/</link>
      <pubDate>Tue, 03 Oct 2017 21:40:07 +0900</pubDate>
      
      <guid>http://cmygray.github.io/post/algorithm/171003_getminsum/</guid>
      <description>문제 자연수로 이루어진 길이가 같은 수열 A,B가 있습니다. 최솟값 만들기는 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱한 값을 누적하여 더합니다. 이러한 과정을 수열의 길이만큼 반복하여 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다.
예를 들어 A = [1, 2] , B = [3, 4] 라면 1. A에서 1, B에서 4를 뽑아 곱하여 더합니다. 2. A에서 2, B에서 3을 뽑아 곱하여 더합니다.
수열의 길이만큼 반복하여 최솟값 10을 얻을 수 있으며, 이 10이 최솟값이 됩니다.</description>
    </item>
    
  </channel>
</rss>