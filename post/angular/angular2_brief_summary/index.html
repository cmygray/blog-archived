<!DOCTYPE html>
<html lang='ko'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Angular summary 참고자료
 poiemaweb tutorials  TODO: 질문
sourcemap 파일과 디버깅의 관계 spec.ts를 생성하지 않는 이유  Common AngularJS =&gt; Angular
 Digest Loop 문제 해결
____Two-way binding;양방향 바인딩 데이터의 change detection;변화감지 개선. AoT Compile, Lazy loading 제공
____성능 개선을 위한 추가 기능을 제공한다는 것은.. 쓰지 않으면 그전과 다를 바 없다는 얘기다.  CLI 개발환경으로서 제공하는 기능
 build Unit test, End to end test env support add/rm element Live reload internal server  $ ng new &lt;project-name&gt; [,--skip-install]: create new project [skip package install]'>

<meta property='og:title' content='Angular summary!!! • cmygray'>
<meta property='og:description' content='Angular summary 참고자료
 poiemaweb tutorials  TODO: 질문
sourcemap 파일과 디버깅의 관계 spec.ts를 생성하지 않는 이유  Common AngularJS =&gt; Angular
 Digest Loop 문제 해결
____Two-way binding;양방향 바인딩 데이터의 change detection;변화감지 개선. AoT Compile, Lazy loading 제공
____성능 개선을 위한 추가 기능을 제공한다는 것은.. 쓰지 않으면 그전과 다를 바 없다는 얘기다.  CLI 개발환경으로서 제공하는 기능
 build Unit test, End to end test env support add/rm element Live reload internal server  $ ng new &lt;project-name&gt; [,--skip-install]: create new project [skip package install]'>
<meta property='og:url' content='http://cmygray.github.io/post/angular/angular2_brief_summary/'>
<meta property='og:site_name' content='cmygray'>
<meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='javascript'><meta property='article:tag' content='typescript'><meta property='article:tag' content='angular'><meta property='article:published_time' content='2017-11-04T23:47:30&#43;09:00'/><meta property='article:modified_time' content='2017-11-04T23:47:30&#43;09:00'/>

<meta name="generator" content="Hugo 0.29" />

  <meta name="google-site-verification" content="Nr7i6uR7CjoTinZAs79UPCich8YNHUGFpCueYNn1yKE" />
  <title>Angular summary!!! • cmygray</title>
  <link rel='canonical' href='http://cmygray.github.io/post/angular/angular2_brief_summary/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Ubuntu:400,400i,700&subset=latin'>
<link rel='stylesheet' href='/assets/css/main.77da63e1.css'><link rel='stylesheet' href='/css/custom.css'>
</head>


<body class='page type-post'>
  <div class='site'>

    <a class='screen-reader' href='#main'>Skip to Content</a>

    <header id='header' class='header-container'>
      <div class='header site-header'>
        <nav id='main-menu' class='main-menu-container' aria-label='Main Menu'>
  <ul class='main-menu'>
  <li>
      <a href='/'>Home</a>
    </li>
  <li>
      <a href='/categories/'>Categories</a>
    </li>
  <li>
      <a href='/tags/'>Tags</a>
    </li>
  <li>
      <a href='https://nullfull.github.io/visual-vocabulary/'>Visual-vocabulary</a>
    </li>
  
  </ul>
</nav>

        <div class='header-info'>
          
          <p class='site-title title'>cmygray</p>
          
          <p class='site-description subtitle'></p>
        </div>
      </div>
    </header>


<main id='main' class='main'>
  <article lang='en' class='entry'>
    <header class='header-container'>
  <div class='header entry-header'>
    <div class='header-info'>
      <h1 class='title'>Angular summary!!!</h1>
      

    </div>
    
<div class='meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader'>Posted on </span>
  <time class='date' datetime='2017-11-04T23:47:30&#43;09:00'>2017, Nov 4</time>
</span>

  
  
<span class='reading-time'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/> 
  
</svg>
10 mins read
</span>


</div>


  </div>
</header>

    
    

    <div class='entry-content'>
  

<h1 id="angular-summary">Angular summary</h1>

<p>참고자료</p>

<ul>
<li><a href="http://poiemaweb.com/angular-basics" target="_blank">poiemaweb tutorials</a></li>
</ul>

<p><strong>TODO:</strong> 질문</p>

<ul class="task-list">
<li><label><input type="checkbox" disabled class="task-list-item"> sourcemap 파일과 디버깅의 관계</label></li>
<li><label><input type="checkbox" disabled class="task-list-item"> spec.ts를 생성하지 않는 이유</label></li>
</ul>

<h2 id="common">Common</h2>

<p>AngularJS =&gt; Angular</p>

<ul>
<li>Digest Loop 문제 해결<br />
____Two-way binding;양방향 바인딩 데이터의 change detection;변화감지 개선.</li>
<li>AoT Compile, Lazy loading 제공<br />
____성능 개선을 위한 추가 기능을 제공한다는 것은.. 쓰지 않으면 그전과 다를 바 없다는 얘기다.</li>
</ul>

<h2 id="cli">CLI</h2>

<p>개발환경으로서 제공하는 기능</p>

<ul>
<li>build</li>
<li>Unit test, End to end test env support</li>
<li>add/rm element</li>
<li>Live reload internal server</li>
</ul>

<p><code>$ ng new &lt;project-name&gt; [,--skip-install]</code>: create new project [skip package install]</p>

<p><code>$ ng serve [,--open] --port &lt;number&gt;]]</code>: preview [open in browser]
* compile
* bundling
* run internal server(port: 4200)
* live reload</p>

<p><code>$ ng build</code>: 배포 (dist/)
* 내부에서 webpack이 작동하며&hellip;
    * ts -&gt; js (transpiling)
    * write map files(for debugging)
    * bundling
    * AoT compile (?)
    * syntax check(error)
    * semantic check(warn)
    * minimize
* 프로덕션 빌드 옵션 <code>--target=production</code> || <code>-prod</code></p>

<p>AoT compile &lt;-&gt; JIT
* template 파일의 컴파일 타임
    * prod build : AoT
    * dev build : JIT<br />
____ng5부터는 둘다 AoT 컴파일</p>

<h2 id="architecture">Architecture</h2>

<p>default scaffolding</p>

<p>my-app/<br />
├── .git/<br />
├── e2e/ (for end to end test)<br />
├── node_modules/<br />
├── <strong>src/</strong><br />
├── .angular-cli.json<br />
├── .editorconfig<br />
├── .gitignore<br />
├── karma.conf.js<br />
├── package.json<br />
├── protractor.conf.js<br />
├── README.md<br />
├── tsconfig.json<br />
└── tslint.json</p>

<p><strong>src</strong> 살펴보기</p>

<p>src/<br />
├── app/: angular 구성요소(컴포넌트, 모듈, 등등 cli에서 생성한 모든 파일)<br />
│   ├── app.component.css<br />
│   ├── app.component.html<br />
│   ├── app.component.spec.ts<br />
│   ├── app.component.ts<br />
│   └── app.module.ts<br />
├── assets/ (static files e.g. img)<br />
├── environments/<br />
│   ├── environment.prod.ts<br />
│   └── environment.ts<br />
├── favicon.ico<br />
├── index.html (default page)<br />
├── main.ts<br />
├── polyfills.ts<br />
├── styles.css (전역에 영향을 미치는 css)<br />
├── test.ts (유닛 테스트용)<br />
├── tsconfig.app.json<br />
├── tsconfig.spec.json<br />
└── typings.d.ts</p>

<p>bootstrap process</p>

<ul>
<li>dist/index.html 로드(5가지 bundle.js 파일을 포함한다)

<ul>
<li>inline</li>
<li>polifills</li>
<li>styles &lt;= style bundles(전역과 스코프 스타일 모두 HTML 헤더로 쪼개져서 들어간다)</li>
<li>vendor &lt;= ng dependency modules</li>
<li><strong>main</strong> &lt;= src/app/*.ts</li>
</ul></li>
<li>angular-cli.json 설정에 의해 main.ts 로드</li>
<li>main.ts에 사전에 작성한 명령에 의해, module bootstrap</li>
<li>app.module에 의해 component bootstrap</li>
<li>component에 의해 템플릿과 데이터가 뷰로 전달된다.</li>
</ul>

<p>app 구성요소</p>

<ul>
<li>component; 컴포넌트

<ul>
<li>template, metadata, class<br />
____뷰 생성이 주 목적. 템플릿 경로(또는 인라인 템플릿), 스타일 경로(또는 인라인 스타일), 셀렉터(상위 컴포넌트 혹은 정적파일(index.html)에서 컴포넌트를 사용하기 위한 태그명)를 데코레이터 함수의 인자로 전달하여 클래스로 공개한다. ng의 핵심! ng의 모든 것!</li>
</ul></li>
<li>directive; 디렉티브

<ul>
<li>=viewless component<br />
____컴포넌트의 스타일, 이벤트, 구조에 대한 정보를 담고 있으며 템플릿에서 타깃 태그의 attribute로써 사용된다. <code>*ngFor</code>, <code>*ngIf</code>, <code>*ngSwitch</code>는 컴포넌트의 구조적 정보를 나타내는 ng native directive.</li>
</ul></li>
<li>service; 서비스

<ul>
<li>application common logic<br />
____애플리케이션 공통 로직에 대한 정보를 담고 있으며 공개한 클래스의 constructor는 의존성 주입이 가능하다.</li>
</ul></li>
<li>router; 라우터

<ul>
<li>replace component</li>
<li>change view</li>
</ul></li>
<li>module; 모듈

<ul>
<li>binding(component + directive + pipe + service) mechanism</li>
</ul></li>
</ul>

<h2 id="component">Component</h2>

<p>(component, directive, pipe) =&gt; view</p>

<p>____웹 표준을 따르는 Web component를 기반으로, HTML과 JS뿐 아니라 CSS까지 독립적인 스코프를 가지도록 부품화한 것. 부품으로 분리할 때 중점은 재사용성이다.</p>

<p>웹 컴포넌트의 기능적 정의(4대 기술 스펙)와 ng component 구현, 사용법</p>

<ol>
<li>뷰를 생성한다(HTML Template)<br />
____컴포넌트 생성 시 개별 템플릿과 스타일을 작성할 수 있다. 또 directive, pipe의 도움을 통해 구조, 스타일, 이벤트, 데이터의 표현방식을 컨트롤 할 수 있다.</li>
<li>스코프를 분리하여 DOM을 캡슐화한다(Shadow DOM)<br />
____컴포넌트의 Encapsulation 옵션 선언을 통해 style 룰셋의 상속을 억제한다.</li>
<li>외부에서 호출이 가능하다(HTML import)<br />
____컴포넌트 생성 시 지정한 셀렉터는 상위 컴포넌트에서 custom tag처럼 사용할 수 있다.</li>
<li>HTML element처럼 명칭(태그 역할을 하는 alias)을 가진다(Custom Element)<br />
____위와 동일</li>
</ol>

<p>컴포넌트 트리</p>

<p>____애플리케이션 각 페이지의 View를 재사용성을 고려해 컴포넌트 단위로 분할하여 컴포넌트 트리를 만든다. 컴포넌트 트리 노드의 연결은 정보 흐름의 통로가 된다. 컴포넌트 분할에 대한 구상은 매우 중요하다.. 아무튼 중요하다&hellip;</p>

<blockquote>
<p><strong>Eat, Sleep, Breath Components!</strong>
Angular is all about components. Design the components first, before starting to code. By design, I mean –
Draw outlines on the Visual-Designs to clearly demarcate which screen area will be owned by which component. Make the components small enough so that they can be reused at many places But large enough that making them any smaller makes no sense. It takes a bit of time to get used to creating this this logical grouping but you can naturally do this in 2–3 sprints. I insist on my entire team doing this for EVERY story in EVERY sprint.
Once you know your component, document the “inputs” and “outputs”. I have a small design-checklist which I make every developer fill-up as a short design documentation for each story. Please see Design Narrative section at the bottom of below this post if you want to adapt it in your project.
Design each component with Re-usability in mind. Try to create commonly used UI element as separate component and re-use them in the screens. <a href="https://hackernoon.com/best-practices-learnt-from-delivering-a-quality-angular4-application-2cd074ea53b3" target="_blank">Vijay Dharap, Best-practices learnt from delivering a quality Angular4 application</a></p>
</blockquote>

<p>컴포넌트 코드의 생김새</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#60a0b0;font-style:italic">// 1. 임포트 영역
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020;font-weight:bold">import</span> { Component } from <span style="color:#4070a0">&#39;@angular/core&#39;</span>;

<span style="color:#60a0b0;font-style:italic">// 2. @Component 데코레이터 영역
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020;font-weight:bold">@Component</span>({
  selector<span style="color:#666">:</span> <span style="color:#4070a0">&#39;app-root&#39;</span>,
  templateUrl<span style="color:#666">:</span> <span style="color:#4070a0">&#39;./app.component.html&#39;</span>,
  styleUrls<span style="color:#666">:</span> [<span style="color:#4070a0">&#39;./app.component.css&#39;</span>]
})
<span style="color:#60a0b0;font-style:italic">// 3. 컴포넌트 클래스 영역
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020;font-weight:bold">export</span> <span style="color:#007020;font-weight:bold">class</span> AppComponent {
  title <span style="color:#666">=</span> <span style="color:#4070a0">&#39;app&#39;</span>;
}</code></pre>
</div>
<ol>
<li>import: 그냥 import다&hellip;</li>
<li>@Component: ng 내장 Component 함수(?)를 데코레이터(<code>@</code>)를 붙여 호출하면 바로 아래에 위치한 class의 constructor를 변경한다.(바로 아래 클래스를 변경하는건 그냥 원래 그런거다. ES7 데코레이터의 기능) 데코레이터로 호출한 Component 함수의 인자는 메타데이터 객체다. 컴포넌트에 대한 정보를 인수로 전달해서 class로 공개될 component의 내용을 채운다.</li>
<li>데코레이터에 전달한 내용을 반영하여 class를 선언한다. 이 클래스는 외부로 공개되며, app.module.ts 파일의 @NgModule 데코레이터의 인수(이것도 메타데이터?)의 일부로 전달됨으로써 호출이 가능해진다. 다만 호출 시엔 클래스명이 아니라 메타데이터에 담긴 셀렉터 프로퍼티를 custom element처럼 사용한다.</li>
</ol>

<p>컴포넌트의 동작</p>

<ul>
<li>템플릿에서 발생한 정보는 이벤트 바인딩을 통해 컴포넌트에게 전달</li>
<li>컴포넌트 클래스가 가진 정보는 프로퍼티 바인딩을 통해 템플릿에게 전달</li>
</ul>

<p>네이밍 규칙</p>

<p>____component 생성 시 hello-world 라는 이름을 전달했다면(command: <code>ng g c hello-world</code>) 관련된 각각의 이름은 아래와 같이 생성된다(cli 사용 시에는 케밥 케이스를 사용하는 것이 좋다).</p>

<ul>
<li>file name: hello-world.component.ts<br />
____convention! 기능을 명확히 설명할 것</li>
<li>selector name: app-hello-world<br />
____이 때 &lsquo;app&rsquo;은 default prefix, 프로젝트 생성 시 옵션 커맨드로 정하거나 생성 후 .angular-cli.json에서 변경한다.</li>
<li>class name: HelloWorldComponent</li>
<li>inner template: <code>&lt;app-hello-world&gt;&lt;/app-hello-world&gt;</code></li>
</ul>

<h3 id="component-template">Component &gt; Template</h3>

<p>컴포넌트 클래스(<strong>C</strong>)와 템플릿(<strong>T</strong>) 연동</p>

<ul>
<li>T to T<br />
=&gt; DOM element 참조정보 전달<br />
____템플릿 내부 임의의 요소 태그에 식별자를 선언(syntax: <code>#refIdentifier</code>)하면, 템플릿 내부에서 변수처럼 사용할 수 있다. 가리키는 값은 DOM element 객체.<br /></li>
<li>C to T<br />
=&gt; 상태정보의 전달<br />
____class에 선언한 property는 템플릿의 ts 컨텍스트에서 참조가 가능하다. *ts 컨텍스트*란 편의상 만든 임의적 명칭으로, 표현식이 요구되는 인터폴레이션(<code>{{ expression }}</code>) 또는 데이터 바인딩 따옴표(<code>&quot;expression&quot;</code>)—정확한 명칭을 알수없다— 내부를 의미한다.<br /></li>
<li>T to C<br />
=&gt; 이벤트 발생정보, 핸들러 함수의 인수 전달<br />
____eventful(?) HTML element가 템플릿에서 사용된다면, 표준 이벤트 바인딩(syntax: <code>(eventName)=&quot;handlerFunc(arg)&quot;</code>)이 가능하다.<br /></li>
</ul>

<h3 id="component-data-binding">Component &gt; Data binding</h3>

<p>컴포넌트 내부에서 클래스가 보유한 정보와 템플릿의 연결을 &ldquo;선언&rdquo;함으로써 Vanillar보다 간결한 DOM 접근 코드.<br />
____대신 무겁다(간결한데 무겁다).</p>

<p>느슨한 바인딩으로 뷰와 모델의 분리가 깔끔하다.<br />
____대신 감지 체계에 배신당한다.</p>

<p>data binding 종류</p>

<ul>
<li>컴포넌트 클래스 to 템플릿<br />
____exp에 컴포넌트 클래스 프로퍼티를 사용할 수 있다. 삼항연산자 사용도 가능하다.<br />

<ul>
<li>interpolation: HTML content | attribute value <code>{{ exp }}</code><br /></li>
<li>prop binding: HTML property(parm) <code>[property]=exp</code></li>
<li>attr binding: HTML attribute(arg) <code>[attrName.]</code><br />
____HTML attr : before parsing(static), DOM property : after parsing(dynamic)</li>
<li>class binding: <code>[class.className]=&quot;booleanExp&quot;</code> OR <code>[class]=&quot;classNames&quot;</code></li>
<li>style binding: <code>[style.styleProp]=&quot;exp&quot;</code><br />
____camelCase, kebap-case 모두 허용</li>
</ul></li>
<li>템플릿 to 컴포넌트 클래스

<ul>
<li>event binding: <code>(eventName)=&quot;statement&quot;</code></li>
</ul></li>
<li>양방향

<ul>
<li>two-way binding(fake): <code>[(ngModel)]=&quot;var(classProp)&quot;</code><br />
____폼 요소의 고유 이벤트를 감지하는 built-in directive <code>ngModel</code>은 별도의 표준 이벤트 바인딩 없이 곧장 컴포넌트 클래스 프로퍼티와 바인딩할 수 있다. 이 때 모듈에 <code>FormsModule</code>을 import해야한다.</li>
</ul></li>
</ul>

<p>Change detection</p>

<p>____angular 사용 상 핵심이 컴포넌트라면, 기능? 원리? 상 핵심은 변화감지. zone.js에 대한 이해가 필요하기 때문에, 그리고 나는 아직 이해를 못했기 때문에&hellip; 배운대로 상태 정보 객체를 변경할 땐 무조건 재할당함으로써 변화감지 체계의 배신을 방지한다. 상태정보를 파헤친 글들만 모아둔 상태.</p>

<ul>
<li><a href="https://www.lucidchart.com/techblog/2016/05/04/angular-2-best-practices-change-detector-performance/" target="_blank">ANGULAR 2 BEST PRACTICES: CHANGE DETECTOR PERFORMANCE</a></li>
<li><a href="https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html" target="_blank">ANGULAR CHANGE DETECTION EXPLAINED</a></li>
</ul>

<h3 id="component-built-in-directive">Component &gt; built-in Directive</h3>

<p>built-in directive 종류</p>

<ul>
<li>Component directive</li>
<li>Attribute directive

<ul>
<li>ngClass: multiple class binding <code>[ngClass]=&quot;exp&quot;</code>, <code>resolvedExp = 'class1 class2 ...' || ['class1', 'class2', ...] || { 'class1': exp, 'class2': exp, ... } || anyMethod(): object</code><br />
____컴포넌트 클래스 프로퍼티에 복수의 클래스명을 할당하고, exp에서 참조한다. 타입은 string(공백 구분), string[], object, method(): object 등등 쓰기 나름. 객체 타입 사용 시 각 프로퍼티를 클래스명으로, 값을 boolean exp로 지정해 클래스 toggle에 응용한다.</li>
<li>ngStyle: <code>*ngStyle=&quot;{ 'cssAttr[.unitPrefix]': exp, ... }&quot;</code><br />
____하나 이상의 스타일을 객체리터럴 형태로 지정한다. 프로퍼티명은 css attribute, 값은 그에 적절한 number 또는 string. number인 경우 단위는 프로퍼티의 suffix로 표시한다.</li>
</ul></li>
<li>Structural directive<br />
____주의사항: host당 한번만 사용.<br />

<ul>
<li>ngIf: <code>*ngIf=exp</code> (exp ? add : don&rsquo;t add), <code>*ngIf=&quot;exp; else elemRef&quot;</code> (exp ? add : add elemRef)<br />
____else를 사용한다면, 템플릿 내부 참조가 필요하기 때문에 템플릿 참조변수나 표현식이 필요하다.</li>
<li>ngFor: <code>*ngFor=&quot;let iter of iters[; let &lt;identifier&gt;=index[; trackBy: &lt;trackMethod&gt;]]&quot;</code>
____index, first, last, even, odd를 변수로 받을 수 있다. <code>trackMethod = (iter type injection?) =&gt; target</code> <strong>TODO: 내용 보충이 필요함</strong></li>
<li>ngSwitch: <code>&lt;base-elem [ngSwitch]=&quot;exp&quot;&gt;&lt;sub-elem *ngSwitchCase=&quot;caseExp&quot;&gt;...&lt;sub-elem *ngSwitchDefault&gt;</code></li>
</ul></li>
</ul>

<p>요소를 숨기는(템플릿 구조를 컨트롤하는) 방법은 여러가지다</p>

<ul>
<li>구조 디렉티브를 써서 DOM에 추가 안하기</li>
<li>DOM에 추가하되 조건부 스타일 바인딩으로 none 또는 hidden 처리</li>

<li><p>css에 display, visible 룰셋을 선언하고, 해당 클래스를 조건부로 부여하기(전통적인&hellip;)</p></li>

<li><p>[ ] <strong>TODO:</strong> display: none, visible: hidden 의 차이점 다시 보기. d: none 해도 inspector element list에선 사라지던데&hellip;</p></li>
</ul>

<h3 id="component-template-ref-var-exp-operator">Component &gt; Template ref var &amp; exp operator</h3>

<p>template ref var</p>

<p>____T to T || T to C, syntax: <code>&lt;target-elem #identifier&gt;...&lt;base-elem (event)=handlerFunc(identifier)&gt;{{ identifier }}</code></p>

<p>template exp operator</p>

<p>____템플릿의 ts context(<code>{{ 여기 }}</code>, <code>[]=&quot;여기&quot;</code>, <code>*ngFor=&quot;let item of items(여기)&quot;</code>, &hellip;) 에서 표현식을 사용할 때 컴포넌트 클래스 프로퍼티를 참조했었다. 이때 함께 사용할 수 있는 연산자를 템플릿 표현식 연산자라고 한다. 데이터를 변경하지 않고 보여주는 방식만 변경한다.</p>

<ul>
<li>Safe nav: <code>exp?</code> — resolved exp가 존재하지 않아도 오류 X</li>
<li>pipe: <code>exp | pipe: *args</code> — resoved exp를 빌트인/[커스텀 파이프]()를 통해 반환한다</li>
</ul>

<h3 id="component-interaction">Component &gt; Interaction</h3>

<p>Component 간 상태 공유</p>

<ul>
<li>top down: <code>@Input</code>, <code>ViewChild</code>, <code>ViewChildren</code></li>
<li>bottom up: <code>@Output</code>(+emitter; 노드 건너뛰기)</li>
<li>미지의 고급진 방법&hellip;: [서비스 중재자](), [NgRx](), [Redux]()</li>
</ul>

<p>@Input</p>

<p>____부모는 자신의 템플릿에서 자식 템플릿을 호출, 동시에 프로퍼티 바인딩을 함으로써 정보를 전달한다. 자식은 자신의 클래스 내부에서 Input 데코레이터를 사용, 전달받은 정보를 프로퍼티에 바인딩한다. Input 데코레이터는 class member를 대상으로 사용되므로 메타데이터 전달과 후행 클래스가 필요없다.</p>

<ul>
<li>parent: <code>&lt;child-component-selector [propName]=&quot;exp&quot;&gt;</code><br />
____부모 컴포넌트가 정보를 전할 땐 프로퍼티 바인딩으로 냅다 보낸다.</li>
<li>child: <code>@Input() propName: type</code><br />
____자식 컴포넌트가 정보를 받을 땐 타입체크만 해주면 된다.</li>
</ul>

<h2 id="directive">Directive</h2>

<ul>
<li>format: HTML element || attribute</li>
<li>role: Direction</li>
<li>view를 가지고 있지 않음</li>
</ul>

<p>종류</p>

<ul>
<li>component</li>
<li>attribute</li>
<li>structure</li>
</ul>

<h2 id="pipe">Pipe</h2>

<h2 id="lifecycle-hooks">Lifecycle Hooks</h2>

<h2 id="service-dependency-injection">Service &amp; Dependency Injection</h2>

<h2 id="rxjs">RxJS</h2>

<h2 id="httpclient">HttpClient</h2>

<h2 id="forms">Forms</h2>

<h2 id="ngmodule">NgModule</h2>

<h2 id="routing">Routing</h2>

<h2 id="deploy">Deploy</h2>

<hr />

<h1 id="others">Others</h1>

<p>지금까지 접한 ng 파일 분할 패턴, 궁금증과 기억해둘 것들</p>

<ul class="task-list">
<li>타입 관리를 위해 클래스 파일을 분할했다<br />
____interface보다 class로 관리하는 것이 더 강력하다는 것을 기억할 것</li>
<li>루트 컴포넌트 템플릿은 실제 상황에선 매우 깨끗하다..</li>
<li><label><input type="checkbox" disabled class="task-list-item"> <strong>TODO:</strong> HTTP 요청 메소드 파일은 어떻게 하는지 모르겠다</label></li>
</ul>

<h2 id="typescript-es6-문법-주워담기">TypeScript, ES6 문법 주워담기</h2>

<h3 id="es6-decorator">ES6 Decorator</h3>

<p>참고 자료| <a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" target="_blank">Exploring EcmaScript Decorators</a></p>

<p>____Angular를 사용하면 데코레이터가 자주 등장하는데, 타입스크립트 데코레이터 문법에 익숙하지 않아 매번 헷갈려서 정리해봤다. (참고글은 ES7에 도입가능성이 있는 데코레이터를 ES6 문법으로 구현하는 내용이다. 구현 코드는 아래에 다시 등장한다.)</p>

<p>문법: <code>@myDecorator</code></p>

<p>____@는 데코레이터 사용 선언을, myDecorator는 앞서 선언한 함수의 이름을 의미한다.</p>

<p>사용패턴</p>

<p>____클래스 멤버 또는 클래스를 대상으로 사용된다. 위 글에 따르면, 프로토타입에 정보가 기록되기 전에 중재자로서 끼어들어 프로퍼티나 클래스를 티 안나게 바꾼다고 한다.</p>

<ul>
<li>클래스 멤버에 사용하는 경우<br />
____데코레이터 함수는 순서대로 target, key, descriptor 세개의 인자를 받을 수 있다.<br />
바로 아랫줄에 작성하는 property를 기준으로 target은 자신을 소유한 객체, key는 이름, descriptor는 자신을 기술하는 객체를 의미한다.</li>
</ul>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#60a0b0;font-style:italic">// 데코레이터로서 호출할 함수 readonly를 작성한다. 대상 프로퍼티(데코레이터로 호출한 뒤에 따라올)의 descriptor 객체의 writable 프로퍼티의 값을 false로 바꾸고, 변경된 descriptor를 반환한다. 즉 대상 프로퍼티를 읽기전용으로 변경한다.
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020;font-weight:bold">function</span> readonly(target, key, descriptor) {
  descriptor.writable <span style="color:#666">=</span> <span style="color:#007020;font-weight:bold">false</span>;
  <span style="color:#007020;font-weight:bold">return</span> descriptor
}

<span style="color:#60a0b0;font-style:italic">// Cat 클래스를 선언한다. readonly 데코레이터는 바로 아래 행에 위치한 meow 메소드를 readonly로 변경할 것이다.
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020;font-weight:bold">class</span> Cat {
  constructor(name) {
    <span style="color:#007020;font-weight:bold">this</span>.name <span style="color:#666">=</span> name;
  }
  <span style="">@</span>readonly
  meow() { <span style="color:#007020;font-weight:bold">return</span> <span style="color:#4070a0">`</span><span style="color:#70a0d0;font-style:italic">${</span><span style="color:#007020;font-weight:bold">this</span>.name<span style="color:#70a0d0;font-style:italic">}</span><span style="color:#4070a0"> says Meow!!`</span>; }
}</code></pre>
</div>
<p>descriptor는 무엇인가?</p>

<p>____<code>Object.getOwnPropertyDescriptor(object, key)</code>를 실행하면 반환하는 객체로, 프로퍼티의 메타데이터를 담고있다. value, writable, enumerable, configurable 프로퍼티를 가진다. (메타데이터라서 프로퍼티에 대한 객체의 프로퍼티&hellip;헷갈리지만 어쩔 수 없다)</p>

<p>데코레이터 없이 Cat 클래스를 선언한다면, 아래와 같은 일이 일어날 것이다. ES6에서 클래스를 구현하는 방식.</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#007020">Object</span>.defineProperties(Cat.prototype, {
  <span style="color:#4070a0">&#39;name&#39;</span><span style="color:#666">:</span> {
    value<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">undefined</span>,
    writable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">true</span>,
    enumerable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">true</span>,
    configurable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">true</span>
  },
  <span style="color:#4070a0">&#39;meow&#39;</span><span style="color:#666">:</span> {
    value<span style="color:#666">:</span> <span style="color:#4070a0">&#39;meow() { return `${this.name} sounds meow!!`; }&#39;</span>,
    writable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">true</span>,
    enumerable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">false</span>,
    configurable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">true</span>
  }
});</code></pre>
</div>
<p>데코레이터를 사용하면, Cat.prototype에 접근하기 이전에 readonly 함수 내부에서 &lsquo;뭔가&rsquo; 일어난다.</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#60a0b0;font-style:italic">// 뒤따르는 meow 메소드를 참조하여 스코프 내에 지역변수를 생성한다.
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020;font-weight:bold">let</span> descriptor <span style="color:#666">=</span> { <span style="color:#60a0b0;font-style:italic">// 기본값을 가진 descriptor가 생성된다.
</span><span style="color:#60a0b0;font-style:italic"></span>  value<span style="color:#666">:</span> <span style="color:#4070a0">&#39;meow() { return `${this.name} sounds meow!!`; }&#39;</span>,
  writable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">true</span>,
  enumerable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">false</span>,
  configurable<span style="color:#666">:</span> <span style="color:#007020;font-weight:bold">true</span>,
};
<span style="color:#60a0b0;font-style:italic">// 지역변수 descriptor를 readonly 함수를 통과시켜 재할당한다. OR 연산자는 작성자가 임의로 넣은 방호코드로 보인다. 여기 쓰인 구현코드가 실제와 정확히 일치한다고 할 수는 없지싶다.
</span><span style="color:#60a0b0;font-style:italic"></span>descriptor <span style="color:#666">=</span> readonly(Cat.prototype, <span style="color:#4070a0">&#39;meow&#39;</span>, descriptor) <span style="color:#666">||</span> descriptor;
<span style="color:#60a0b0;font-style:italic">// readonly 함수를 거쳐서 writable: false 프로퍼티를 지니도록 변경된 descriptor를 사용, 비로소 프로토타입에 정보를 저장한다.
</span><span style="color:#60a0b0;font-style:italic"></span><span style="color:#007020">Object</span>.defineProperty(Cat.prototype, <span style="color:#4070a0">&#39;meow&#39;</span>, descriptor)</code></pre>
</div>
<p>이제 Cat 클래스 인스턴스의 meow 프로퍼티에 변경을 시도하면 Exeption 에러가 발생할 것이다.</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#007020;font-weight:bold">var</span> nyang <span style="color:#666">=</span> <span style="color:#007020;font-weight:bold">new</span> Cat(<span style="color:#4070a0">&#39;nayang&#39;</span>);
nyang.meow <span style="color:#666">=</span> <span style="color:#007020;font-weight:bold">function</span>() { console.log(<span style="color:#4070a0">&#39;냥냥냥&#39;</span>) };
<span style="">// Exeption</span></code></pre>
</div>
<ul>
<li>클래스에 사용하는 경우<br /></li>
</ul>

</div>

    
<footer class='entry-footer-container'>
  <div class='entry-footer'>
  <div class='categories'>
  <span class='taxonomyTerm-icon'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M22,19a2,2,0,0,1-2,2H4a2,2,0,0,1-2-2V5A2,2,0,0,1,4,3H9l2,3h9a2,2,0,0,1,2,2Z"/>
  
</svg>
</span>
  <span class='screen-reader'>Categories: </span><a class='category' href='/categories/javascript'>Javascript</a>, <a class='category' href='/categories/angular'>Angular</a></div>
<div class='tags'>
  <span class='taxonomyTerm-icon'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
</span>
  <span class='screen-reader'>Tags: </span><a class='tag' href='/tags/javascript'>Javascript</a>, <a class='tag' href='/tags/typescript'>Typescript</a>, <a class='tag' href='/tags/angular'>Angular</a></div>

  </div>
</footer>


  </article>
  
<nav class='entry-nav-container'>
  <div class='entry-nav'><div class='prev-entry'>
      <a href='/post/til/171104_til/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader'>Previous post: </span>171104_TIL</a>
    </div><div class='next-entry'>
      <a href='/post/til/171106_til/'>
        <span class='screen-reader'>Next post: </span>171106_TIL<span aria-hidden='true'>Next <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>

  
<div class='comments-container'>
  <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "cmygray" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</main>

    <footer id='footer' class='footer-container'>
      <div class='footer'>
        <div class='social-menu-container'>
  <nav aria-label='Social Menu'>
    <ul class='social-menu'><li>
        <a href='mailto:cmygray@gmail.com' target='_blank' rel='noopener'>
          <span class='screen-reader'>Contact via Email</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
  <polyline points="22,6 12,13 2,6"/>
  
</svg>
</a>
      </li><li>
        <a href='https://facebook.com/cmygray' target='_blank' rel='noopener'>
          <span class='screen-reader'>Open Facebook account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/>
  
</svg>
</a>
      </li><li>
        <a href='https://github.com/cmygray' target='_blank' rel='noopener'>
          <span class='screen-reader'>Open Github account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
  
</svg>
</a>
      </li><li>
        <a href='https://instagram.com/cmygray' target='_blank' rel='noopener'>
          <span class='screen-reader'>Open Instagram account in new tab</span><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="2" y="2" width="20" height="20" rx="5" ry="5"/>
  <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/>
  <line x1="17.5" y1="6.5" x2="17.5" y2="6.5"/>
  
</svg>
</a>
      </li></ul>
  </nav>
</div>
        <div class='copyright'>

  <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br
  />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.

</div>

      </div>
    </footer>

  </div><script src='/assets/js/main.f29c93b9.js'></script><script src='/js/custom.js'></script></body>

</html>

